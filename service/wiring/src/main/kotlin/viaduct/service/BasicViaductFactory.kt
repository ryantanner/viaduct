package viaduct.service

import viaduct.api.bootstrap.ViaductTenantAPIBootstrapper
import viaduct.apiannotations.TestingApi
import viaduct.service.api.SchemaId
import viaduct.service.api.Viaduct
import viaduct.service.api.spi.TenantCodeInjector
import viaduct.service.runtime.SchemaConfiguration
import viaduct.service.runtime.StandardViaduct

object BasicViaductFactory {
    /**
     * A simple factory-function for [Viaduct] instances.
     *
     * This function assumes that the class path includes the class
     * and resource files generated by the Viaduct tenant build plugin.
     *
     * Production code should use this method and rely on default GRT schema discovery.
     * Test code that needs to override GRT package prefix should use [createForTesting].
     *
     * @param schemaRegistrationInfo schemas available for serving.  By default, only
     *    the full schema is available under schemaId "" (empty string).
     *    In production, grtPackagePrefix and grtResourcesIncluded should not be set
     *    (leave as null to use defaults).
     *
     * @param tenantRegistrationInfo tenant configuration including tenantPackagePrefix and
     *    injector to be used to instantiate resolvers and other tenant code.  The injector
     *    defaults to using reflection and assuming that there are no-arg constructors
     *    for all tenant code. The tenantPackagePrefix is always configurable.
     */
    fun create(
        schemaRegistrationInfo: SchemaRegistrationInfo = SchemaRegistrationInfo(),
        tenantRegistrationInfo: TenantRegistrationInfo,
    ): Viaduct {
        val builder = builderWithTenantInfo(tenantRegistrationInfo)
        val schemaConfiguration = applySchemaRegistry(schemaRegistrationInfo)
        return builder.withSchemaConfiguration(schemaConfiguration).build()
    }

    /**
     * Test-only factory function for [Viaduct] instances that allows overriding GRT schema discovery settings.
     *
     * This method should only be used in tests that need to override the default GRT package prefix
     * or resource pattern. Production code should use [create] which relies on default GRT discovery.
     *
     * @param scopes schemas available for serving.  By default, only the full schema is available.
     * @param tenantRegistrationInfo tenant configuration including package prefix and injector.
     * @param grtPackagePrefix package prefix for GRT schema file discovery (test override only).
     * @param grtResourcesIncluded regex pattern for GRT schema files (test override only).
     */
    @TestingApi
    fun createForTesting(
        scopes: List<SchemaScopeInfo> = listOf(),
        tenantRegistrationInfo: TenantRegistrationInfo,
        grtPackagePrefix: String? = null,
        grtResourcesIncluded: String? = null,
    ): Viaduct {
        val schemaRegistrationInfo = SchemaRegistrationInfo(
            scopes = scopes,
            grtPackagePrefix = grtPackagePrefix,
            grtResourcesIncluded = grtResourcesIncluded
        )
        val builder = builderWithTenantInfo(tenantRegistrationInfo)
        val schemaConfiguration = applySchemaRegistry(schemaRegistrationInfo)
        return builder.withSchemaConfiguration(schemaConfiguration).build()
    }

    // internal for testing
    internal fun builderWithTenantInfo(tenantRegistrationInfo: TenantRegistrationInfo): StandardViaduct.Builder {
        val builder = StandardViaduct.Builder()
            .withTenantAPIBootstrapperBuilder(
                ViaductTenantAPIBootstrapper.Builder()
                    .tenantPackagePrefix(tenantRegistrationInfo.tenantPackagePrefix)
                    .tenantCodeInjector(tenantRegistrationInfo.tenantCodeInjector)
            )
        return builder
    }

    // internal for testing
    internal fun applySchemaRegistry(schemaRegistrationInfo: SchemaRegistrationInfo): SchemaConfiguration {
        val scopeConfigs = schemaRegistrationInfo.scopes.map { scope ->
            if (scope.scopesToApply.isNullOrEmpty()) {
                SchemaConfiguration.ScopeConfig(scope.schemaId, emptySet())
            } else {
                SchemaConfiguration.ScopeConfig(scope.schemaId, scope.scopesToApply)
            }
        }

        return SchemaConfiguration.fromResources(
            grtPackagePrefix = schemaRegistrationInfo.grtPackagePrefix,
            resourcesIncluded = schemaRegistrationInfo.grtResourcesIncluded?.toRegex(),
            scopes = scopeConfigs.toSet()
        )
    }
}

data class TenantRegistrationInfo(
    val tenantPackagePrefix: String,
    val tenantCodeInjector: TenantCodeInjector = TenantCodeInjector.Naive,
)

/**
 * A descriptor for a (scoped) schema to be registered into a [Viaduct] engine.
 *
 * @param scopes The set of scope defining parameters
 * @param grtPackagePrefix the package prefix to search for GRT schema (.graphqls) files.
 *        For testing only - production should use null to rely on default discovery.
 * @param grtResourcesIncluded the regex to match GRT schema files to include.
 *        For testing only - production should use null to rely on default pattern.
 *  */
data class SchemaRegistrationInfo(
    val scopes: List<SchemaScopeInfo> = listOf(),
    val grtPackagePrefix: String? = null,
    val grtResourcesIncluded: String? = null,
)

/**
 * A descriptor for a scoped schema configuration.
 *
 * @param schemaId The id for the scoped schema
 * @param scopesToApply The set of scope-ids that define the scoped schema.
 *                      If null or empty, the full schema is used.
 */
data class SchemaScopeInfo(
    val schemaId: String = "",
    val scopesToApply: Set<String>? = null,
)

fun SchemaId.Scoped.toSchemaScopeInfo(): SchemaScopeInfo = SchemaScopeInfo(this.id, this.scopeIds.ifEmpty { null })

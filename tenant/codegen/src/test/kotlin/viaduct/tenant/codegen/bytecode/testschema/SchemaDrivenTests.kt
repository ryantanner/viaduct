package viaduct.tenant.codegen.bytecode.testschema

import graphql.schema.idl.SchemaParser
import graphql.schema.idl.UnExecutableSchemaGenerator
import java.io.File
import kotlin.test.assertTrue
import kotlinx.coroutines.test.runBlockingTest
import org.junit.jupiter.api.Test
import viaduct.codegen.utils.JavaName
import viaduct.engine.api.ViaductSchema
import viaduct.graphql.schema.ViaductSchema as ViaductGraphQLSchema
import viaduct.graphql.schema.graphqljava.extensions.fromTypeDefinitionRegistry
import viaduct.graphql.schema.graphqljava.readTypes
import viaduct.graphql.utils.DefaultSchemaProvider
import viaduct.invariants.InvariantChecker
import viaduct.tenant.codegen.bytecode.CodeGenArgs
import viaduct.tenant.codegen.bytecode.GRTClassFilesBuilder
import viaduct.tenant.codegen.bytecode.config.ViaductBaseTypeMapper
import viaduct.tenant.codegen.bytecode.exercise.ClassResolver
import viaduct.tenant.codegen.bytecode.exercise.Exerciser
import viaduct.tenant.codegen.bytecode.util.assumedClassesForCodegen
import viaduct.utils.timer.Timer

/** End-to-end tests of generated byte codes for the test schema. */
class SchemaDrivenTests {
    private fun prepareSchemaFiles(): List<File> =
        listOf("graphql/bytecode_test_schema.graphqls", "graphql/classic.graphqls")
            .map { resourcePath ->
                val resourceStream = this::class.java.classLoader.getResourceAsStream(resourcePath)
                    ?: error("Resource not found: $resourcePath")
                val tempFile = File.createTempFile("schema-", ".graphqls")
                tempFile.deleteOnExit()
                tempFile.outputStream().use { output ->
                    resourceStream.use { input ->
                        input.copyTo(output)
                    }
                }
                tempFile
            }

    @Test
    fun reflectionDrivenExercisesV2() =
        runBlockingTest {
            val failures = InvariantChecker()

            val sdl = DefaultSchemaProvider.getDefaultSDL(
                existingSDLFiles = prepareSchemaFiles(),
                includeNodeDefinition = DefaultSchemaProvider.IncludeNodeSchema.Always,
                includeNodeQueries = DefaultSchemaProvider.IncludeNodeSchema.Never
            )

            val schema = ViaductGraphQLSchema.fromTypeDefinitionRegistry(SchemaParser().parse(sdl))
            val graphqlSchema = ViaductSchema(UnExecutableSchemaGenerator.makeUnExecutableSchema(readTypes(sdl)))

            val args = prepareCodeGenArgs(schema, "viaduct.api.grts")
            val builder = GRTClassFilesBuilder(args)
                .addAll(schema)

            // V2/modern tests should use ViaductBaseTypeMapper
            // Note: V2/modern code uses parameter-passing, not cfg.baseTypeMapper
            val classLoader = builder.buildClassLoader()
            val exerciser = Exerciser(
                check = failures,
                classResolver = ClassResolver.fromClassLoader(JavaName("viaduct.api.grts"), classLoader),
                schema = schema,
                graphqlSchema = graphqlSchema,
            )
            exerciser.exerciseGeneratedCodeV2()
            if (!failures.isEmpty) {
                println("Test failures found:")
                failures.toListOfErrors().forEach { println(it) }
            }
            assertTrue(failures.isEmpty, "Expected no failures, but found:\n${failures.joinToString("\n")}")
        }

    private fun prepareCodeGenArgs(
        schema: ViaductGraphQLSchema,
        pkgForGeneratedClasses: String
    ): CodeGenArgs =
        CodeGenArgs(
            moduleName = null,
            pkgForGeneratedClasses,
            includeIneligibleTypesForTestingOnly = false,
            excludeCrossModuleFields = false,
            javaTargetVersion = null,
            workerNumber = 0,
            workerCount = 1,
            timer = Timer(),
            baseTypeMapper = ViaductBaseTypeMapper(schema),
        )

    @Test
    fun invariantChecker() {
        // Call KmContext.check to check invariants of result from loadGraphQLSchema
        // Classic test should use AirbnbBaseTypeMapper

        val sdl = DefaultSchemaProvider.getDefaultSDL(
            existingSDLFiles = prepareSchemaFiles(),
            includeNodeDefinition = DefaultSchemaProvider.IncludeNodeSchema.Always,
            includeNodeQueries = DefaultSchemaProvider.IncludeNodeSchema.Never
        )

        val schema = ViaductGraphQLSchema.fromTypeDefinitionRegistry(SchemaParser().parse(sdl))

        val args = prepareCodeGenArgs(schema, "com.airbnb.viaduct.schema.generated")

        GRTClassFilesBuilder(args)
            .addAll(schema)
            .checkInvariants(allowedSuperTypes = assumedClassesForCodegen)
            .isEmpty
    }
}
